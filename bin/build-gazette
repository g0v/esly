#!/usr/bin/env perl
use v5.14;
package PassionFruit;
use File::Next;
use File::Slurp qw(read_file);
use Moo;
use ElasticSearch;

has es => (
    is => "lazy",
    isa => sub {
        ref($_[0]) eq "ElasticSearch" or die "Not an ElasticSearch object.\n";
    }
);

has gazette_source => (
    is => "ro",
    required => 1,
    isa => sub {
        my $src = $_[0];
        -d "$src/raw" or die "$src is nnot a directory.\n";
        -f "$src/raw/3867.md" or die "$src is not a directory with gazette raw data files.\n";
    }
);

has index_name => (
    is => "lazy",
    isa => sub {
        $_[0] =~ /\A g0vtw _ [0-9]{8} _ [0-9]{6} \z/x
    }
);

sub _build_es { return ElasticSearch->new }

sub _build_index_name {
    my ($sec,$min,$hour,$mday, $mon, $year) = localtime(time);
    return sprintf "g0vtw_%04d%02d%02d_%02d%02d%02d", 1900+$year, $mon, $mday, $hour, $min, $sec;
}

sub walk_gazettes {
    my $self = shift;

    $self->create_index;

    my $it = File::Next::files($self->gazette_source);
    while(defined( my $file = $it->() )) {
        next unless $file =~ m!/raw/(?<number>\d+)\.md$!a;
        my $gazette_content = $self->read_gazette($file);
        $self->index_gazette(
            number  => $+{number},
            content => $gazette_content,
        );
    }
}

sub read_gazette {
    my ($self, $file) = @_;
    my $content = read_file($file, { binmode => ":utf8" });

    # strip json block
    $content =~ s!\n [ \t]*```json \n (.+) \n [ \t]*```\n!!gsx;

    # strip table.
    $content =~ s!\n \<table [^\n]+ \n !!gsmx;

    return $content;
}

sub create_index {
    my $self = shift;
    $self->es->create_index(
        index => $self->index_name,
        settings => {
            index => {
                analysis => {
                    filter => {
                        bigram_and_trigram => {
                            type => "nGram",
                            min_gram => 2,
                            max_gram => 3,
                        }
                    },
                    analyzer => {
                        GazetteContentAnalyzer => {
                            type => "chinese",
                            tokenizer => "whitespace",
                            filter      => ["bigram_and_trigram", "trim"],
                            char_filter => ["html_strip"]
                        }
                    }
                },
            }
        },
        mappings => {
            LyGazetteText => {
                _id => { "path" => "issue" },
                properties => {
                    issue => {
                        type => "integer"
                    },
                    content => {
                        type => "string",
                        analyzer => "GazetteContentAnalyzer"
                    },
                }
            }
        }
    );

    say "Created index: " . $self->index_name;
}

sub index_gazette {
    my ($self, %args) = @_;

    say "Issue $args{number} has content with " . length($args{content}) . " characters";

    $self->es->index(
        index => $self->index_name,
        type  => "LyGazetteText",
        data  => {
            issue   => $args{number},
            content => $args{content},
        }
    );
}

package main;
binmode STDOUT, ":utf8";

my $p = PassionFruit->new( gazette_source => $ARGV[0] );

$p->walk_gazettes;
